<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Credentials on Daniel Brennand</title><link>https://danielbrennand.com/tags/credentials/</link><description>Recent content in Credentials on Daniel Brennand</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Thu, 22 Dec 2022 23:39:10 +0100</lastBuildDate><atom:link href="https://danielbrennand.com/tags/credentials/index.xml" rel="self" type="application/rss+xml"/><item><title>PowerShell: Storing Credentials Securely</title><link>https://danielbrennand.com/blog/powershell-storing-credentials/</link><pubDate>Thu, 22 Dec 2022 23:39:10 +0100</pubDate><guid>https://danielbrennand.com/blog/powershell-storing-credentials/</guid><description>Recently I&amp;rsquo;ve been working on several PowerShell scripts that require credentials to access REST APIs. In this blog post, I will showcase two approaches for storing credentials securely for use in PowerShell scripts.
Encrypted Password File ðŸ”’ The encrypted password file leverages the Windows Data Protection API (DPAPI) to encrypt the password as a System.Security.SecureString:
$Credentials = Get-Credential $Credentials.Password System.Security.SecureString $Credentials.Password | ConvertFrom-SecureString 01000000d08c9ddf0115d1118c7a00c04fc297eb01000000f5ab85d7ee9da048ae4ae797ee7eaf0a000000000200000000001066000000010000200000008c4a03d2f0731e0e7661d695fda8b441eaff31e75724931f31374a0c8292b636000000000e800000000200002000000028da885828bd627480178382ce9a1b477819e7703546ce41819d37f4e63d33ba20000000ab2c4401635ec24db9f20071e18dea0b79ce16ba38b5503ec9937b7fbc849dcf40000000155053a793c210998ef7317b0161e7344c2174b904b527c0cf24e7bbf2243b99e936df3ab67bc9e285a1be33aed37c7604fb07f5d0c44ceb7d6334ca30b0a610 By default DPAPI uses the current user context to generate an encryption key.</description></item></channel></rss>